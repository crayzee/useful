# Файл docker-compose должен начинаться с тега версии.
# Мы используем "3" так как это - самая свежая версия на момент написания этого кода.
version: '3.7'

# Следует учитывать, что docker-composes работает с сервисами.
# 1 сервис = 1 контейнер.
# Сервисом может быть клиент, сервер, сервер баз данных...
# Раздел, в котором будут описаны сервисы, начинается с 'services'.
services:

  # Как уже было сказано, мы собираемся создать клиентское и серверное приложения.
  # Это означает, что нам нужно два сервиса.
  # Первый сервис (контейнер): сервер базы данных.
  # Назвать его можно так, как нужно разработчику.
  # Понятное название сервиса помогает определить его роль.
  # Здесь мы, для именования соответствующего сервиса, используем ключевое слово 'db'.

  useful-db:
    container_name: useful-db
    image: postgres:12
    restart: on-failure
    env_file:
      - ./.env.dev
    ports:
      - 5432:5432
    volumes:
      - usefulpgdata:/var/lib/postgresql/data

  # Typically, we don’t deploy a PgAdmin container alongside a PostgreSQL container in a production configuration.
  # https://habr.com/ru/company/ruvds/blog/450312/
  pgadmin4:
    image: dpage/pgadmin4
    environment:
      PGADMIN_DEFAULT_EMAIL: twopik@gmail.com
      PGADMIN_DEFAULT_PASSWORD: oilgas
    ports:
      - "8889:80"
    depends_on:
      - useful-db

  back:
    container_name: useful-back

    # Очень долго возился с проблемой. Если я запускался не из докера, а из poetry shell, авторизация по Гитхабу не
    # вызывала проблем. Однако, когда я переходил на докер, то долго не мог понять, почему у меня возникает таймаут при
    # попытке получить инфу о юзере. Сначала выдавало httpx.connectTimeout после 5 с (оказалось, что 5 с - это дефолтн
    # значение таймаута. Я поставил таймаут = 13, и тогда понял, что ответ от github приходил с задержкой 5-15 с, а
    # иногда и вовсе таймаут на 15-20с, что было очень нестабильно. Потом начал копать в тему DNS и понял, что копаю
    # верно. В итоге, после рисерча, оказалось достаточно прописать dns:
    dns:
      - 8.8.8.8

    # Ключевое слово "build" позволяет задать
    # путь к файлу Dockerfile, который нужно использовать для создания образа,
    # который позволит запустить сервис.
    # Здесь 'server/' соответствует пути к папке сервера,
    # которая содержит соответствующий Dockerfile.
    build:
      context: ./
      dockerfile: Dockerfile
    env_file:
      - ./.env.dev
    volumes:
      - ./:/app

    # Если мы хотим обратиться к серверу с нашего компьютера (находясь за пределами контейнера),
    # мы должны организовать перенаправление этого порта на порт компьютера.
    # Сделать это нам поможет ключевое слово 'ports'.
    # При его использовании применяется следующая конструкция: [порт компьютера]:[порт контейнера]
    # В нашем случае нужно использовать порт компьютера 8000 и организовать его связь с портом
    # 80 контейнера (так как именно на этот порт сервер ожидает поступления запросов).
    ports:
      - 8000:80
    restart: always
    
    # Ключевое слово 'depends_on' позволяет указывать, должен ли сервис,
    # прежде чем запуститься, ждать, когда будут готовы к работе другие сервисы.
    # Нам нужно, чтобы сервис 'useful-back' дождался бы готовности к работе сервиса 'useful-db'.
    depends_on:
      - useful-db

    # Ключевое слово 'network_mode' используется для описания типа сети.
    # Тут мы указываем то, что контейнер может обращаться к 'host' компьютера.
    #network_mode: host
      
    # Команда, которую нужно запустить после создания образа.
    # Следующая команда означает запуск "python ./server.py".
    command: /start-reload.sh


volumes:
  usefulpgdata: